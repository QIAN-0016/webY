<!DOCTYPE html>
<!-- saved from url=(0047)http://down.scscms.com/scs/waterfall/index.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <title>JQUERY瀑布流</title>
    <style>
        body, div, dl, dt, dd, ul, ol, li, h1, h2, h3, h4, h5, h6, pre, form, fieldset, input, p, blockquote, th, td { margin:0; padding:0; }
        body{overflow-x: hidden;background-color: #464742}
        h1, h2, h3, h4, h5, h6 { font-size:100%;}
        img{ border:0}
        a{color: #fff;}
        #container{ font-size:12px;text-align:center;background-color: #464742;position: relative;border: 5px solid #fff;}
        .cell{
            padding:10px 10px 0; border:1px solid #31312d; background:#31312d;
            width:194px;position: absolute;overflow: hidden;
            display: none;border-bottom: 30px solid #22221e
        }
        .cell img{width:192px}
        .cell h3{color: #fff;text-align: left;margin-top: 10px;}
        #container p{line-height:20px; margin-top:5px;color: #fff;text-align: left;margin-bottom: 20px;}
    </style>
<script src="../../static/js/jquery.js"></script>
</head>
<body>
<div id="container" style="height: 918px;">
    <div class="cell" style="top: 0px; left: 0px; display: block;"><img src="../../static/img/waterfall/P_000.jpg"><h3>JQUERY瀑布流原理</h3><p>这里也有一个瀑布流效果，但效果不好。</p></div>
    <div class="cell" style="top: 0px; left: 224px; display: block;"><img src="../../static/img/waterfall/P_001.jpg"><h3>JQUERY瀑布流原理</h3><p>它的排版原理是先统计多少列，然后生成一排DIV。</p></div>
    <div class="cell" style="top: 0px; left: 448px; display: block;"><img src="../../static/img/waterfall/P_002.jpg"><h3>JQUERY瀑布流原理</h3><p>然后统计这排DIV的高度来分配图片的排版。开始加载感觉不出问题来。如果窗口变化几次排序就会乱了，打乱原有的排序，而且它是直接修改了节点结构，而且很卡甚至卡死。</p></div>
    <div class="cell" style="top: 0px; left: 672px; display: block;"><img src="../../static/img/waterfall/P_003.jpg"><h3>JQUERY瀑布流原理</h3><p>JQUERY瀑布流原理：我们应该保持原有节点不要更改，只修改图片的div坐标位置达到排序功能。</p></div>
    <div class="cell" style="top: 0px; left: 896px; display: block;"><img src="../../static/img/waterfall/P_004.jpg"><h3>JQUERY瀑布流原理</h3><p>JQUERY瀑布流原理：每次排版取前一排最低的位置接着排，窗口改变后先计算一下列数有没有发生变化，变化后才重排。每张图片的位置也比较一下有没有发生变化，变化后才重排，这点对窗口变化后非常有效。</p></div>
    <div class="cell" style="top: 0px; left: 1120px; display: block;"><img src="../../static/img/waterfall/P_005.jpg"><h3>JQUERY瀑布流原理</h3><p>JQUERY瀑布流原理：如果图片加载过程中，窗口发生变化，我们是没有执行重排动作。</p></div>
    <div class="cell" style="top: 0px; left: 1344px; display: block;"><img src="../../static/img/waterfall/P_006.jpg"><h3>JQUERY瀑布流原理</h3><p>因为重排的条件是必须全部图片已经加载并渲染完毕。所以当加载过程中发生窗口变化，先记录下来，等加载完后再处理。</p></div>
    <div class="cell" style="top: 0px; left: 1568px; display: block;"><img src="../../static/img/waterfall/error.jpg"><h3>JQUERY瀑布流原理</h3><p>JQUERY瀑布流原理：还有如果图片地址出错将终止排序功能，为了解决这问题我们准备好一张错误提醒图片替换它。</p></div>
    <div class="cell" style="top: 292px; left: 672px; display: block;"><img src="../../static/img/waterfall/P_008.jpg"><h3>JQUERY瀑布流原理</h3><p>JQUERY瀑布流原理：每次排版取前一排最低的位置接着排，窗口改变后先计算一下列数有没有发生变化，变化后才重排。当下拉滚动条达到最后一个DIV的顶部时请求ajax生成新的图片插到底部执行继排功能。</p></div>
    <div class="cell" style="top: 383px; left: 1568px; display: block;"><img src="../../static/img/waterfall/P_009.jpg"><h3>JQUERY瀑布流原理</h3><p>JQUERY瀑布流原理：每次排版取前一排最低的位置接着排，窗口改变后先计算一下列数有没有发生变化，变化后才重排。当下拉滚动条达到最后一个DIV的顶部时请求ajax生成新的图片插到底部执行继排功能。</p></div>
    <div class="cell" style="top: 416px; left: 1120px; display: block;"><img src="../../static/img/waterfall/P_010.jpg"><h3>JQUERY瀑布流原理</h3><p>JQUERY瀑布流原理：每次排版取前一排最低的位置接着排，窗口改变后先计算一下列数有没有发生变化，变化后才重排。当下拉滚动条达到最后一个DIV的顶部时请求ajax生成新的图片插到底部执行继排功能。</p></div>
    <div class="cell" style="top: 428px; left: 1344px; display: block;"><img src="../../static/img/waterfall/P_011.jpg"><h3>JQUERY瀑布流原理</h3><p>JQUERY瀑布流原理：每次排版取前一排最低的位置接着排，窗口改变后先计算一下列数有没有发生变化，变化后才重排。当下拉滚动条达到最后一个DIV的顶部时请求ajax生成新的图片插到底部执行继排功能。</p></div>

</div>
<script>
    $(function(){waterfall(".cell")});
    function waterfall(cls){
        if(!$(cls).length) return;//没有元素
        var con={
            obj:null,//图片div对象
            l:0, //总共数量
            w:214,//列宽
            s:10,//列间距
            list:0, //多少列
            h:1, //外div的高
            arr:[],//最后一排数组
            state:"loading" //状态 loading:加载图片中，ajax:正在发生ajax请求，finish:完成任务，load_resize:加裁过程中窗口变化(记录起来，加载完后处理)，resize:执行了窗口变化，reset:窗口变化排序中再次重排
        };
        con.obj=$(cls);//图片div对象
        con.l=con.obj.size();//统计共有多少个图片div
        con.list=Math.floor($("#container").width()/(con.w+con.s));//统计共有多少列
        fall_pic(0);
        $(window).resize(function(){
            var w=Math.floor($("#container").width()/(con.w+con.s));//重新统计共有多少列
            if(w!=con.list){
                //窗口变化造成列数发生了变化
                if("loading|load_resize|ajax".indexOf(con.state)!=-1){
                    //如果正在加载中,需要加载完后再执行重排
                    con.state="load_resize";
                }else{
                    //已经排完或者执行重排过程
                    con.list=w;
                    con.h=1;
                    if("finish"==con.state){
                        con.state="resize";//执行重排
                        fall_pic(0);
                    }else{
                        con.state="reset";//重排中的重排
                        //因为已经在重排过程中，不能再次调用函数。但可让编号再从0开始
                    }
                }
            }
        }).scroll(function(){
                    if("finish"==con.state){
                        var top=con.obj.last().offset().top;//最后一张图片的坐标
                        var scrollTop=document.documentElement.scrollTop||document.body.scrollTop||0;//滚动条距离
                        var windowHeight=document.documentElement.clientHeight||document.body.clientHeight||0;//窗口高度
                        if(windowHeight+scrollTop>=top){
                            con.state="ajax";//当滚动条拉到看到最后一张图片时
                            var html='';//实现案例中此改成ajax请求json或html,每次请求只增加一排
                            for(var i=con.l;i<con.l+con.list*2;i++){
                                html+='<div class="cell"><img src="http://cued.xunlei.com/demos/publ/img/P_'+('00'+i%162).slice(-3)+'.jpg" /><h3>'+i+' AJAX加载</h3><p>JQUERY瀑布流原理：每次排版取前一排最低的位置接着排，窗口改变后先计算一下列数有没有发生变化，变化后才重排。当下拉滚动条达到最后一个DIV的顶部时请求ajax生成新的图片插到底部执行继排功能。</p></div>';
                            }
                            $("#container").append(html);
                            con.obj=$(cls);//更新对象
                            var _i=con.l;//记录加载前的最后一个编号
                            con.l=con.obj.size();//统计现在共有多少张图片
                            fall_pic(_i);//接着加载前最一张图片排序;
                        }
                    }
                });
        function fall_pic(n){
            if("reset"==con.state){
                n=0;//处理重排中窗口再次变化
                con.state="resize";
            }
            //以下con.state可能存在的值为 loading,ajax,load_resize,resize
            if(n<con.l){
                var obj=con.obj.eq(n);//获取对象
                var x= 0,y=0;//对象坐标值
                if(n<con.list){
                    x=n*(con.w+con.s);//如果是第一排，y=0,x=宽度+列间距
                    con.arr[n]=obj;//把最后一排对象组成数组供后面用
                }else{
                    var _i=0;//查一下最后一排哪张图片的底部离顶部最高，然后在其后面插入新图片
                    for(var i= 0;i<con.list;i++){
                        var _top=con.arr[i].position().top+con.arr[i].outerHeight(true)+con.s;
                        if(0==y)y = _top;
                        if(y>_top){
                            _i=i;
                            y=_top;
                            x=i*(con.w+con.s);
                        }
                    }
                    console.log(y);
                    con.arr[_i]=obj;//替换数组
                }
                if("resize"==con.state){
                    //如果是窗口变化，属于重排，不需要预加载图片
                    if(y==obj.position().top&&x==obj.position().left){                        
                        n++;//原位不变的跳过排序动画
                        fall_pic(n);
                    }else{
						//$("body,html").scrollTop(y);//设置滚动条，与动画同步
                        obj.animate({top:y,left:x},"fast",function(){
                            var _h=obj.position().top+obj.outerHeight(true);							
                            if(_h>con.h){
                                con.h=_h;
                                $("#container").stop().animate({height:_h},"fast");//设置外框高
                            }
                            n++;
                            fall_pic(n);
                        });
                    }
                }else{
                    var img=new Image();
                    img.onload=function(){
						//$("body,html").scrollTop(y);//设置滚动条，与动画同步
                        obj.css({top:y,left:x}).fadeIn("slow",function(){
                            var _h=obj.position().top+obj.outerHeight(true);
                            if(_h>con.h){
                                con.h=_h;
                                $("#container").stop().animate({height:_h},"fast");//设置外框高
                            }
                            n++;
                            fall_pic(n);
                        });
                    };
                    img.onerror=function(){
                        //加载失败就替换图片，并省去设置外围div的高
                        obj.css({top:y,left:x}).fadeIn("slow",function(){
                            n++;
                            fall_pic(n);
                        }).find("img").attr("src","error.jpg");
                    };
                    img.src=obj.find("img").attr("src");
                }
            }else{
                setTimeout(function(){
                    if("load_resize"==con.state&&con.list!=Math.floor($("#container").width()/(con.w+con.s))){
                        con.state="finish";//如果是在预加载图片时改变了窗口大小需要重排的情况
                        $(window).resize();
                    }else{
                        con.state="finish";//延时一下，以防自动不断触发scroll
                    }
                },300)
            }
        }
    }
</script>

</body></html>